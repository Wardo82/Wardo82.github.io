<html>

<head>
    <title>Tum Computer Science Room Finder</title>
    <link rel="shortcut icon" href="about:blank">
    <!-- Load Frameworks that are needed for AR and QR logic -->
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <script src="https://aframe.io/releases/0.8.0/aframe.min.js"></script>
    <script src="https://jeromeetienne.github.io/AR.js/aframe/build/aframe-ar.js"></script>
    <script src="https://cdn.rawgit.com/donmccurdy/aframe-extras/v4.0.2/dist/aframe-extras.min.js"></script>
    <script src="https://cozmo.github.io/jsQR/jsQR.js"></script>
    <!-- Load modules for Queues, Vertices, Graph and Hashmaps-->
    <script type="text/javascript" src="js/Vertex.js"></script>
    <script type="text/javascript" src="js/PriorityQueue.js"></script>
    <script type="text/javascript" src="js/Graph.js"></script>
    <script type="text/javascript" src="js/RoomStore.js"></script>
    <script type="text/javascript" src="js/Translation.js"></script>
    <style type="text/css">
        .qr-data-info {
            position: fixed;
            top: 0px;
            left: 0px;
            background: rgba(204, 204, 204, 0.3);
            padding: 5px;
        }

        .tool-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            background: rgba(204, 204, 204, 0.3);
            padding: 5px;
        }

        .tool-bar .btn-clear {
            font-size: 20px;
            text-decoration: none;
            color: black;
        }
    </style>

    <script type="text/javascript">
        try {
            AFRAME.registerComponent('rotation-reader', {
                tick: function () {
                    var rotCamera = this.el.object3D.rotation;
                    var rotArrow = objectEntity.object3D.rotation;
                    if (originNode && autoEnabled) {
                        objectEntity.object3D.rotation.set(
                            - rotCamera['x'],
                            - rotCamera['y'],
                            rotArrow['z']);
                        var x = document.getElementById('x');
                        x.innerHTML = rotCamera['x'];
                        var y = document.getElementById('y');
                        y.innerHTML = rotCamera['y'];
                        var z = document.getElementById('z');
                        z.innerHTML = rotCamera['z'];
                    }
                }
            });
        } catch (error) {
            alert(error.message);
        }
    </script>
</head>

<body style='margin : 0px; overflow: hidden;'>

    <a-scene embedded arjs="debugUIEnabled: false;" vr-mode-ui="enabled: false">
        <a-assets>
            <a-asset-item id="arrow" src="assets/arrow2.gltf"></a-asset-item>
        </a-assets>

        <a-entity camera="active: true" look-controls rotation-reader data-aframe-default-camera>
            <a-entity id="arrowObject" gltf-model="#arrow" position="0 0 -0.6" rotation="0 0 0" scale="0.05 0.05 0.05"
                visible="false"></a-entity>
        </a-entity>
    </a-scene>

    <div class="qr-data-info">
        QR Data : <span id="qrData"></span> <br>
        Alpha : <span id="angleData"></span> <br>
    </div>

    <div class="tool-bar">
        <p id="x"></p>
        <p id="y"></p>
        <p id="z"></p>
        <a href="#" class="btn-clear">Clear</a>
    </div>


    <script type="text/javascript">
        try {
            //Get Object Element: Arrow or Pin
            objectEntity = document.getElementById('arrowObject');
            // Get destination out of local storage
            var destRoomInput = localStorage.getItem('input_search');
            //Build Graph
            // Instance of graph
            var graph = new UndirectedGraph();
            var a = new Vertex(1);
            var b = new Vertex(2);
            var c = new Vertex(3);
            var d = new Vertex(4);
            var e = new Vertex(5);
            // Node addition
            graph.addVertex(a);
            graph.addVertex(b);
            graph.addVertex(c);
            graph.addVertex(d);
            graph.addVertex(e);

            a.setDistance(b, 10);
            b.setDistance(c, 10);
            c.setDistance(d, 10);
            c.setDistance(e, 10);

            graph.addEdge(a, b, 90);
            graph.addEdge(b, c, 90);
            graph.addEdge(c, e, 180);
            graph.addEdge(c, d, 0);

            console.log(graph.Dijkstra(a, b));

            //Assign Rooms to Nodes
            var rooms = new RoomStore();
            rooms.addFinger("00.01.*", 1);
            rooms.addFinger("00.02.*", 2);
            rooms.addFinger("01.03.*", 4);
            rooms.addRoom("01.04.005", 5);



            /*
            *   oldQRCodeValue and nextDestination both hold a number that represents a node of the graph
            *   Based on these two attributes the system decides if a new path has to be rendered and what model to display on-top of the marker
            */
            var oldQRCodeValue = '';
            var nextDestination = '';
            var autoEnabled = false;
            var counter = 0;


            //Objects that can be displayed
            objects3D = {
                'arrow': 'http://home.in.tum.de/~gruberfe/mms/assets/arrow.gltf',
                'pin': 'http://home.in.tum.de/~gruberfe/mms/assets/CesiumMan.gltf',
            };

            canvasElement = document.createElement("canvas");
            canvasContext = canvasElement.getContext("2d");

            var rot = 0;

            var transLat = new Translation();
            var originNode;
            var destRoom = rooms.getRoom("01.04.005");
            var destination = graph.getVertexById(destRoom);

            //Try to read a QR Code every 500 Milliseconds and change model based on its value
            setInterval(function () {
                //rot=(rot+45)%360;
                //objectEntity.setAttribute('rotation', {x:0,y:rot,z:0});
                video = document.querySelector("video");
                if (video && video.readyState === video.HAVE_ENOUGH_DATA) {
                    canvasElement.height = video.videoHeight;
                    canvasElement.width = video.videoWidth;
                    canvasContext.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
                    //Reading out QR, Code by using the current frame of the camera produced by aFrame
                    var imageData = canvasContext.getImageData(0, 0, canvasElement.width, canvasElement.height);
                    var qrCode = jsQR(imageData.data, imageData.width, imageData.height);
                    if (qrCode && qrCode.data != '' && qrCode.data != oldQRCodeValue) {
                        counter = 0;
                        autoEnabled = true;
                        //Calculate Shortest Path from current Node
                        originNode = graph.getVertexById(qrCode.data);
                        if (originNode) {
                            objectEntity.object3D.visible = true;
                        }
                        var shortestPath = graph.getPathBetween(originNode, destination);

                        var degree = shortestPath[0].getDegree(shortestPath[1].id);


                        //Get Degree
                        //alert(qrCode.data);
                        var angle = transLat.getOrientation(qrCode);
                        angle = (angle + degree) % 360;
                        var angleRad = transLat.toRadian(angle);
                        try {
                            objectEntity.object3D.rotation.set(0, 0, angleRad);
                            //objectEntity.object3D.rotateOnAxis(new THREE.Vector3(0, 0, 1), angleRad);
                            //objectEntity.object3D.rotateZ(angleRad);
                        } catch (error) {
                            alert(error.message);
                        }
                        alert("Reached");
                        $('#angleData').text(angle + "Rad: " + angleRad);
                        //Load Model Arrow
                        gltfModel = objects3D['arrow'];
                        if (gltfModel) {
                            //objectEntity.setAttribute('gltf-model', 'url(' + gltfModel + ')');
                        } else {
                            alert('Cannot find arrow.gltf model! Please check assets folder!');
                        }
                        oldQRCodeValue = qrCode.data;
                        console.log(qrCode.data);
                        $('#qrData').text(qrCode.data);
                    } if (qrCode && qrCode.data != '' && qrCode.data == destRoom) {
                        //Load Model Pin
                        gltfModel = objects3D['pin'];
                        if (gltfModel) {
                            //objectEntity.setAttribute('gltf-model', 'url(' + gltfModel + ')');
                        } else {
                            alert('Cannot find pin.gltf model! Please check assets folder!');
                        }
                    } else {
                        counter += 300;
                        if (counter >= 1200) {
                            autoEnabled = true;
                        }
                        console.log('Currently there is no readable QR-Code!');
                    }
                }
            }, 300);

            $('.btn-clear').click(function () {
                oldQRCodeValue = '';
                $('#qrData').text(oldQRCodeValue);
                objectEntity.removeAttribute('gltf-model');
            });

        } catch (error) {
            alert(error.message)
        }
    </script>

</body>

</html>
